---
title: 'あああああ'
emoji: '🍙'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['nextjs']
published: false
---

# はじめに

Next.js 12.1 で [On-demand ISR(Beta)](https://nextjs.org/blog/next-12-1#on-demand-incremental-static-regeneration-beta) がリリースされました。
この記事では、作成したデモサイトを見ながら、Next.js にデータフェッチをさわっていきます。

# 前提

今回作成したデモサイトは[こちら](https://next-data-fetching-sample.vercel.app/)です。
API から受けとった情報を表示する簡単なサイトです。
https://github.com/TakaShinoda/next-data-fetching-sample

下記のように、ワンピース麦わらの一味のメンバーの中からランダムに 1 名の情報と
その時の日時を返す API を作成しました。

```
{
  "date": "2022/04/12 21:02:22",
  "name": "モンキー・D・ルフィ",
  "img": "https://1.bp.blogspot.com/-tVeC6En4e_E/X96mhDTzJNI/AAAAAAABdBo/jlD_jvZvMuk3qUcNjA_XORrA4w3lhPkdQCNcBGAsYHQ/s400/onepiece01_luffy.png",
  "berry": "15億",
  "role": "船長"
}
```

![](https://storage.googleapis.com/zenn-user-upload/8b23851dcc09-20220412.png)

# CSR: Client-side rendering

## 使い所や利点

- ページが SEO インデックスを必要としない場合
- データを事前にレンダリングする必要がない場合
- ページのコンテンツが頻繁に更新される場合
- コンポーネントレベルでデータ取得ができる

## 留意点

- アプリケーションのパフォーマンスとページのロード速度に影響を与える可能がある
  - データ取得がコンポーネントやページのマウント時に行われ、データがキャッシュされないため

デモサイトでは `useEffect` を使用してデータを取得しています。

```tsx: pages/csr.tsx
import type { NextPage } from 'next'
import { FetchData } from '../components/FetchData'

const Csr: NextPage = () => {
  return (
    <section className="text-gray-600">
      <FetchData />
    </section>
  )
}

export default Csr
```

```tsx: components/FetchData.tsx
import React, { useEffect, useState, FC } from 'react'
import Image from 'next/image'

export const FetchData: FC = () => {
  const [data, setData] = useState<any>(null)
  const [isLoading, setLoading] = useState(false)

  useEffect(() => {
    setLoading(true)
    try {
      fetch('api/hello')
        .then((res) => res.json())
        .then((data) => {
          setData(data)
          setLoading(false)
        })
    } catch (err) {
      console.log(err)
    }
  }, [])

  if (isLoading) return <p>Loading...</p>
  if (!data) return <p>No data</p>

  return (
		// 略
  )
}
```

Next.js の開発チームが作成した [SWR](https://swr.vercel.app/ja) というデータフェッチ用のライブラリもあります。

# SSR: Server-side rendering

## 使い所や利点

- リクエスト時にデータを取得しなければならないページをレンダリングする必要がある場合
- 内部でエラーが発生した場合は `pages/500.js` が表示される

## 留意点

- `getServerSideProps` から API Routes を呼びだすと余計なリクエストが発生してしまう
  - サーバー上で `getServerSideProps` と API Routes の両方が動作して余計なリクエストは発生してしまうため
  - 代わりに API ルート内で使用されているロジックを直接 `getServerSideProps` にインポートする

```tsx: pages/ssr.tsx


```

# SG: Static Generation

## 使い所や利点

- ページのレンダリングに必要なデータが、ユーザのリクエストに先立ってビルド時に利用可能な場合
- データがヘッドレス CMS からくる場合
- データが一般にキャッシュされている (ユーザ固有ではない) 場合
- `getStaticProps` はサーバサイドでのみ実行されるので、クライアントサイドで実行されることはない
- ブラウザ用の JS バンドルにも含まれないので、ブラウザに送信されることなく、直接データベースクエリを書くことができる
- API ルートを使ってデータを取得しないのであれば、 `getStaticProps` で直接 fetch API を使ってデータを取得することも可能

## 留意点

- クライアント側で実行されることはない
- getStaticProps から API ルートを直接呼び出すと追加の呼び出しを生成し、パフォーマンスを低下させる
  - 代わりに、CMS からデータを取得するためのロジックを、lib ディレクトリを使用して共有する

```tsx: lib/fetch-data.ts
export const fetchData = async() => {
	const res = await fetch(
	  'https://next-data-fetching-sample.vercel.app/api/hello'
	)
	const data = await res.json()
	return data
}
```

```tsx: pages/sg.tsx
import type { GetStaticProps } from 'next'
import Image from 'next/image'
import { fetchData } from '../lib/fetch-data'

const Sg = ({ data }) => {
  return (
    // 略
  )
}

export const getStaticProps: GetStaticProps = async () => {
  const data = await fetchData()
  return { props: { data } }
}

export default Sg
```

# ISR: Incremental Static Regeneration

```tsx: pages/isr.tsx
import type { GetStaticProps } from 'next'
import Image from 'next/image'
import { fetchData } from '../lib/fetch-data'

const Isr = ({ data }) => {
  return (
		// 略
  )
}

export const getStaticProps: GetStaticProps = async () => {
  const data = await fetchData()
  return {
    props: {
      data,
    },
    revalidate: 10,
  }
}
export default Isr
```

- `getStaticProps` に `revalidate` のプロップを追加することで使用可能
- ビルド時にプリレンダリングされたページに対してリクエストが発生すると最初はキャッシュされたページが表示
- 最初のリクエストの後、`revalidate` の値 (今回は 10 秒) 以内に行われたページへのリクエストもキャッシュされ即座に表示される
- `revalidate` の値 (今回は 10 秒) を過ぎても、次のリクエストではキャッシュされた（古くなった）ページが表示される
  - その時に、Next.js はバックグラウンドでページ再生のトリガーをかける
  - ページの再生成に成功すると、Next.js はキャッシュを無効化し、更新されたページを表示する
  - もしバックグラウンドでの再生成に失敗しても、古いページは変更されない
